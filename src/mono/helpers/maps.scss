@use "sass:meta";
@use 'sass:map';
@use 'sass:list';
@use 'sass:string';

// Move to utils/map
@function map-sort-by-values($map) {
  // Transform map to zipped list
  $keys: ();
  $values: ();

  @each $key, $val in $map {
    $keys: append($keys, $key);
    $values: append($values, $val);
  }

  $list: zip($keys, $values);

  $sortedMap: ();
  @while length($list) > 0 {

    // Find smallest pair
    $smallestPair: nth($list, 1);
    @each $pair in $list {
      $value: nth($pair, 2);
      $smallestValue: nth($smallestPair, 2);
      @if $value < $smallestValue {
        $smallestPair: $pair;
      }
    }

    // Add smallest pair to sorted map
    $key: nth($smallestPair, 1);
    $value: nth($smallestPair, 2);
    $sortedMap: map-merge($sortedMap, ($key: $value));

    // Remove from list smallest pair
    $smallestPairIndex: index($list, $smallestPair);
    $newList: ();
    @for $i from 1 through length($list) {
      @if $i != $smallestPairIndex {
        $newList: append($newList, nth($list, $i), "space");
      }
    }
    $list: $newList;
  }

  @return $sortedMap;
}

// Get unquoted value from a map
@function map-get-plain($map, $keys...) {
  $value: map.get($map, $keys...);
  @return safe-unquote($value);
}

// Get value from a config map
@function config($keys...) {
  $value: map.get($configs, $keys...);
  @return $value;
}

// Get value from a tokens map
@function token($keys...) {
  $value: map.get($tokens, $keys...);
  @return $value;
}

// Get color value from token map
// 
// For color palletes you can use `*` to mark primary color,
// this will allow for a shorter syntax.
// 
// Example:
// `color(grey)` -> $token: grey > 300* -> #fafafa
//
// Usage:
// color(white)
// color(purple, 300)
//
@function color($keys...) {
  $color-found: false;
  $stringKeys: ();

  @for $i from 1 through length($keys) {
    $key: nth($keys, $i);
    $stringKeys: append($stringKeys, string.quote(to-lower-case(#{$key})));
  }

  $color: token(color, $stringKeys...);

  @if (type-of($color) == 'map') {
    $keys-list: map.keys($color);

    @each $key in $keys-list {
      @if (string.index($key, '*')) {
        $color-found: true;
        $color: map.get($color, $key);
      }
    }

    @if (not $color-found) {
      @error 'There is no main color defined. Use named key to access the color. Available keys: #{$keys-list}';
    }
  } @else if (type-of($color) == 'color') {
    $color-found: true;
  }

  @if (not $color-found) {
    @error 'Color not found. Check if #{$keys} exist in tokens.'
  }

  @return $color;
}

// Get breakpoint value from tokens map
@function breakpoint($keys...) {
  $value: token(breakpoints, $keys...);
  @return $value;
}

// Get map of sorted breakpoints prepended with `'default': 0` from tokens map
@function sortedBreakpoints() {
  @return map-sort-by-values(map.merge(token(breakpoints), ('default': 0)));
}

// Get value from slots map
@function slot($keys...) {
  $value: map.get($slots, $keys...);

  @if type-of($value) == 'map' and not list.index(map.keys($value), 'default') { 
    @error 'Looks like this slot goes deeper, please extend your slot arguments. Available keys: #{map.keys($value)}.'; 
  }

  @if $value == null { 
    @error 'There is no slot defined for #{$keys}'; 
  }

  @if type-of($value) == 'string' {
    @if string.index($value, '(') and string.index($value, ')') == string.length($value) {
      $m: str-split(string.slice(str-replace($value, ' ', ''), 1, -2), '(');
      $func: list.nth($m, 1);
      $args: str-split(list.nth($m, 2), ',');

      @if meta.function-exists($func) {
        $value: meta.call(meta.get-function($func), $args...);
      }
    }
  }
  
  @return $value;
}

// Get color value from slot map
@function color-slot($keys...) {
  $value: slot(color, $keys...);

  @return color($value...);
}

// Get grid value from slot map
@mixin grid-slot($name) {
  $value: slot(grid, $name);

  grid-column: unquote($value);
}

// Get responsive pair of attribute & value from slot map.
// Slot should be a map of valid breakpoints as keys.
//   
// Usage:
// responsive-slot('grid-column', grid, component, small) 
// -> slot: grid > component > small
// ->
@mixin responsive-slot($attr, $keys...) {
  $map: slot($keys...);
  $check: false;

  @if (type-of($map) == 'map') {
    @each $screen, $value in sortedBreakpoints() {
      $stepSize: map.get($map, $screen);

      @if ($stepSize != null) {
        $check: true;

        @include screen($screen) {
          #{$attr}: unquote($stepSize);
        }
      }
    }

    @if (not $check) {
      @error 'No breakpoints found. You need to select a key that returns a map containing one of following keys: #{map.keys(sortedBreakpoints())}';
    }

  } @else {
    @error 'No map found. Instead had: Type <#{type-of($map)}>: #{$map}';
  }
}
