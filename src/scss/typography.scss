@use 'sass:math';
@use 'sass:map';
@use 'sass:list';
@use 'sass:string';

$font-schema: (
  fontFamily: 'font-family',
  fontSize: 'font-size',
  lineHeight: 'line-height',
  fontWeight: 'font-weight',
  fontStyle: 'font-style',
  fontStretch: 'font-stretch',
  letterSpacing: 'letter-spacing',
  textCase: 'text-transform',
  textDecoration: 'text-decoration'
);

$typography-map: ();

@function generate-font-attributes-map($font-name, $font-map) {
  $output: ();

  @each $key, $name in $font-schema {
    $value: map.get($font-map, $key);

    @if ($name == 'font-family') {
      // merging token font with a fallbacks defined in config
      $font-fallback: config(typography, fontFallbacks, '#{$value}');
      @if ($font-fallback) {
        $combined-value: "#{$value}, #{$font-fallback}";
        $output: map.set($output, $name, string.unquote($combined-value));
      } @else {
        $output: map.set($output, $name, $value);
      }
    } @else if ($name == 'font-size') {
      @if (config(typography, fluid) and config(layout, breakpoints, typography-fluid) and list.index(config(typography, fluidExclude), $font-name) == null) {
        $baseFontSize: config(typography, baseFontSize);

        $minScreen: config(layout, breakpoints, typography-fluid, start);
        $maxScreen: config(layout, breakpoints, typography-fluid, end);

        $minFont: rem(token(font, default, $font-name, fontSize));
        $maxFont: rem(token(font, desktop, $font-name, fontSize));

        $factor: calc(calc(1 / calc($maxScreen - $minScreen)) * calc($maxFont - $minFont));

        $rem: $minFont - $minScreen * $factor;
        $vw: (100 * $factor) * 1vw;

        $value: clamp($minFont, calc($vw + $rem), $maxFont);
        $output: map.set($output, $name, $value);
      } @else {
        $output: map.set($output, $name, rem($value));
      }
    } @else if ($name == 'line-height') {
       $output: map.set($output, $name, math.div($value, map.get($font-map, 'fontSize')));
    } @else if ($name == 'letter-spacing') {
      $output: map.set($output, $name, rem($value));
    } @else {
      $output: map.set($output, $name, $value);
    }
  }
  @return $output;
}

// Parse token fonts map into typography map for use in a mixin
@each $screen, $map in token('font') {
  @each $name, $font in $map {
    $sanitizedName: str-replace($name, ' ', '-');

    $typography-map: map.set($typography-map, $sanitizedName, $screen, generate-font-attributes-map($name, $font));
  }
}

// Generates font styles with all breakpoints that were defined in the Figma
@mixin typography($name) {
  @each $screen, $styles in map.get($typography-map, $name) {
    @if ($screen == 'default') {
      @each $attr, $value in $styles {
        #{$attr}: $value;
      }
    } @else {
      @include screen($screen) {
        @each $attr, $value in $styles {
          #{$attr}: $value;
        }
      }
    }
  }
}
